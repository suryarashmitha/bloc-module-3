#### Questions

> What is a binary tree and what makes it unique to other trees?

A: A binary tree is a data structure that starts with root data and branches in two directions, left and right. Each child node branches into two (left and right) as well, and the structure continues to do so with all of its data.

> What is a heuristic?

A: A heuristic is the guesses an algorithm makes, which sacrifice accuracy in order to solve the problem quicker.

> What is another problem besides the shortest-path problem that requires the use of heuristics?

A: Searching for a specific node from a binary tree that consists of 1000 nodes.

> What is the difference between a depth-first search and a breadth-first search?

A: Depth-First and Breadth-First, Both are algorithms used for traversing or searching tree or graph data structures. In DFS we start at the root and explore as far as possible along each branch before backtracking. In BFS we start at the tree root and explore the neighbour nodes first, before moving to the next level neighbours. 

> Explain in your own words what an undirected, a-cyclic, unweighted graph is.

A: IN an undirected graph, the edge connecting two nodes is ambiguous. It neither starts nor ends at either Node, it merely connects the two like hands in a handshake. In a-cyclic  graph, Nodes don't form loops; performing a DFS of an A-cyclic Graph will result in a dead-end. Unweighted graphs do not assign cost of travel between nodes. 

> What kind of graph is a binary search tree?

A:Directed, a-cyclic and unweighted graphs.

####Programming Questions

1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.

—>Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

A: Starting at root, check left and right branches to see if value exists, return true if so, false if not.

class Node {
	constructor(data) {
		this.data = data;
		this.left = null;
		this.right = null;
	}
}

class BinarySearchTree {
	constructor() {
		this.root = null;
	}

	contains(data) {
		var found = false;
		var thisNode = this.root;
		while (!found && thisNode) {
			if (data < thisNode.data) {
				thisNode = thisNode.left;
			} else if (data > thisNode.data) {
				thisNode = thisNode.right;
			} else {
				found = true;
			}
		}
		return found;
	}

	insert(data) {
		var newNode = new Node(data);
		if (this.root === null) {
			this.root = newNode;
			this.length++;
		} else {
			this.insertNode(this.root, newNode);
		}
	}

	insertNode(node, newNode) {
		if (newNode.data < node.data) {
			if (node.left === null) {
				node.left = newNode;
				this.length++;
			} else {
				this.insertNode(node.left, newNode);
			}
		} else {
			if (node.right === null) {
				node.right = newNode;
				this.length++;
			} else {
				this.insertNode(node.right, newNode);
			}
		}
	}
}

var BST = new BinarySearchTree();

BST.insert(8);
BST.insert(3);
BST.insert(10);
BST.insert(1);
BST.insert(6);
BST.insert(14);
BST.insert(4);
BST.insert(7);
BST.insert(13);

console.log(BST.contains(8)); 
console.log(BST.contains(23)); 
console.log(BST.contains(14)); 

2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.


—> Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1. The distance between the nodes 1 and 14 is 4.

A: Add distance between n1 and root and n2 and root and subtract 2*distance between root and lowest common ancestor.

class Node {
	constructor(data) {
		this.data = data;
		this.left = null;
		this.right = null;
	}
}

class BinarySearchTree {
	constructor() {
		this.root = null;
	}

	findDistanceBetweenTwoNodes(root, n1, n2) {
		var lowestCommonAncestor = this.findCommonAncestor(root, n1, n2);
		var distanceNode1ToRoot = this.countAncestors(lowestCommonAncestor, n1);
		var distanceNode2ToRoot = this.countAncestors(lowestCommonAncestor, n2);
		var distanceRootToAncestor = this.countAncestors(root, lowestCommonAncestor);
		var totalDistance = (distanceNode1ToRoot + distanceNode2ToRoot) - (2 * distanceRootToAncestor);
		return ('The distance between node ' + n1 + ' and node ' + n2 + ' is ' + totalDistance);
	}

	findCommonAncestor(root, n1, n2) {
		if (!root) return;
		var lowestCommonAncestor = root.data;
		if (n1 === lowestCommonAncestor || n2 === lowestCommonAncestor) {
			return lowestCommonAncestor;
		}
		if (n1 < lowestCommonAncestor && n2 < lowestCommonAncestor) {
			return this.findCommonAncestor(root.left, n1, n2);
		}
		if (n1 > lowestCommonAncestor && n2 > lowestCommonAncestor) {
			return this.findCommonAncestor(root.right, n1, n2);
		}
		return lowestCommonAncestor;
	}

	countAncestors(root, data) {
		let thisNode = this.root;
		let nodeCount = 0;
		while (thisNode) {
			if (data === thisNode.data) {
				return nodeCount;
			}
			thisNode = data < thisNode.data ? thisNode.left : thisNode.right;
			nodeCount++;
		}
	}

	getRootNode() {
		return this.root;
	}

	insert(data) {
		var newNode = new Node(data);
		if (this.root === null) {
			this.root = newNode;
			this.length++;
		} else {
			this.insertNode(this.root, newNode);
		}
	}

	insertNode(node, newNode) {
		if (newNode.data < node.data) {
			if (node.left === null) {
				node.left = newNode;
				this.length++;
			} else {
				this.insertNode(node.left, newNode);
			}
		} else {
			if (node.right === null) {
				node.right = newNode;
				this.length++;
			} else {
				this.insertNode(node.right, newNode);
			}
		}
	}
}

var BST = new BinarySearchTree();

BST.insert(8);
BST.insert(3);
BST.insert(10);
BST.insert(1);
BST.insert(6);
BST.insert(14);
BST.insert(4);
BST.insert(7);
BST.insert(13);

var root = BST.getRootNode();
console.log(BST.findDistanceBetweenTwoNodes(root, 1, 14));